[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18434385&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.

    The systematic application of engineering principles to the design, development, testing, deployment, and maintenance of software.
    It's important in the tech industry because it supports Innovation in Emerging Technologies, Artificial intelligence, blockchain, cloud computing, and IoT, all of which depend on software engineering. Engineers develop and maintain the algorithms, platforms, and infrastructures that power these innovations, pushing technological advancements forward.

Identify and describe at least three key milestones in the evolution of software engineering.
        
      The Emergence of Agile Methodologies (2001-Present) – The Agile Manifesto was introduced in 2001, promoting iterative 
                                                            development, collaboration, and flexibility over rigid, document-
                                                            heavy approaches like the Waterfall model.
                                                            Agile methodologies such as Scrum and Kanban have since dominated 
                                                            modern software engineering, enabling teams to 
                                                            adapt quickly to changing requirements and deliver high-quality 
                                                            software efficiently.
                                                             
                                                            
                                                            

      The Advent of Open Source Software (1990s-Present) –  The rise of open-source software, with projects like Linux, 
                                                            Apache, and GitHub,transformed the industry by fostering 
                                                            collaboration and knowledge 
                                                            sharing. Open-source development
                                                            enables rapid innovation, reduces costs, and provides access to 
                                                            high-quality software tools and frameworks that 
                                                            power modern applications.
                                                            

      The Shift to Cloud Computing (2006-Present) –         With the launch of Amazon Web Services (AWS) in 2006, cloud 
                                                            computing became a game-changer in software 
                                                            engineering.
                                                            Cloud platforms allow businesses to build, deploy, and scale 
                                                            applications without the need for extensive on-
                                                            premise infrastructure, leading to the widespread adoption of 
                                                            microservices, serverless computing, and DevOps 
                                                            practices.
                                                            


List and briefly explain the phases of the Software Development Life Cycle.

           1. Planning –   This phase involves defining project goals, scope, feasibility, and resource allocation.
                            Stakeholders analyze business needs and establish a clear roadmap for development.

           2. Requirements Gathering & Analysis – Developers and business analysts collect detailed functional and 
                                                  non-functional requirements from users and stakeholders. This ensures 
                                                  that the software meets business and technical needs before development begins.

           3. Design(Creating prototypes, etc) – System architects and developers create blueprints for the software, including 
                                                 system architecture, database design, user interfaces, and security protocols. 
                                                 This phase establishes the foundation for implementation.

          4. Programming – Developers write the code based on the design specifications. This is the core phase where the software
                           is built using programming languages, frameworks, and tools.

          5. Testing and Debugging – The software is rigorously tested for bugs, security vulnerabilities, and performance issues.
                                     Testing methods include unit testing, integration testing, system testing, and user acceptance 
                                     testing (UAT) to ensure quality and reliability.

          6. Deployment – Once testing is complete, the software is deployed to a production environment where users can access it. 
                          This may involve cloud deployment, server configuration, and data migration.

          7. Maintenance & Support – After deployment, developers provide updates, bug fixes, and improvements based on user feedback. 
                                     Continuous monitoring ensures the software remains functional, secure, and up-to-date.


Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.

    Approach –  Waterfall follows a linear, sequential process where each phase must be completed before moving to the next. 
                Agile, on the other hand, is iterative and flexible, breaking the project into smaller cycles (sprints) that allow for continuous feedback and 
                    improvements.

    Flexibility – Waterfall is rigid, changes are difficult to implement once a phase is completed. 
                  Agile is highly adaptable, allowing changes even late in the development process based on user feedback.

    Project Scope and Requirements – Waterfall requires well-defined and stable requirements upfront, making it ideal for projects with little uncertainty.
                                     Agile works best when requirements may evolve over time and user involvement is needed for ongoing refinements.

    Delivery and Testing – Waterfall delivers the final product at the end of the development cycle, with testing occurring near completion. 
                           Agile delivers working software in small increments, with testing integrated into each sprint to catch issues early.

    Team Collaboration – Waterfall teams have minimal interaction between phases. 
                        Agile promotes close collaboration between members working on different phases, ensuring continuous feedback and alignment.

                                        Appropriate Scenarios for Each Methodology
    Waterfall is best for projects with clear, fixed requirements and minimal expected changes. Like government contracts, large-scale infrastructure software.

    Agile is ideal for projects with evolving requirements and a need for rapid iterations. Like mobile app development, AI-powered applications, etc, where the customer 
    feedback plays a crucial role in refining features over time.


Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

    Software Developer – Writes, tests, and maintains code to develop software applications.

    Quality Assurance (QA) Engineer – Ensures software quality by designing and executing test plans. Identifies bugs, 
                                      security vulnerabilities, and performance issues through manual and automated testing. 
                                      Works closely with developers to report defects and verify fixes.

    Project Manager (PM) – Oversees project execution, ensuring timelines, budgets, and scope are met. 
                           Facilitates communication between stakeholders, assigns tasks, manages risks, 
                           and ensures Agile, Scrum, or Waterfall methodologies are properly implemented
                                       


Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

     IDE -  Creates an environment where codes can be written. They also help in enhancing code efficiency by highlighting 
            the required syntax while coding to prevent chances of creating errors. An example is Visual Studio Code. 
     VCS -  Enhances collaboration and teamwork by enabling parallel development, supports code backups and recovery incase 
            of technical issues. An example is Git, GitBash 


What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
     
    Keeping up with rapidly changing technology -  Developers can overcome tis challane by continously learning about the 
                                                   updated technologies through blogs and practice on how to use them. 

    Meeting Tight deadlines - Developers can achive this by using the Agile methodology which breakes large projects into 
                              small managable segments. They could also automate repetitive tasks.

    Burn outs and Mental Fatigue - Developers can avoid /reduce burnouts by setting personal boundaries by avoiding to work 
                                   overtime
    

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

    Unit testing- ensures individual components work correctly, I helps developers to catch bugs early and modify the code 
                  with cofidence.
    Integration testing- ensures correct interactions between components and that data flows correctly, it helps prevent 
                         broken integration .
    System testing- Tests the end-to-end functionality to ensure that the system meets the requirements, it ensures complete 
                    system functionality.
    Acceptance testing- Normally done by the customer to confirm that the software meets the business requirements, it help 
                        reduce post release problems.

#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.

      It involves structuring queries in a way that guides the AI to generate more accurate, relevant, and useful outputs.
      It's important because it helps :  Reduce bias misisnterprations by being specific in your requests
                                         Generate high quality outpus
                                         Save time on getting the right output.

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

     VAGUE PROMPT - Create an image of a CEO who's a  young-adult african female speaking ata a tech confrence.
     IMPROVED PROMPT -  A young African woman with a fair dark complexion stands with confidence, exuding ambition and authority. She has a short, neatly styled afro and 
                        wears clear glasses with a thin gold rim. Her expression is serious yet determined, with sharp, focused eyes. She is dressed in olive-green cargo 
                        pants with multiple pockets, detailed stitching, and a slightly loose fit, paired with a fitted, long-sleeved black top that boldly displays 'CEO' 
                        across the chest in white. The texture of her clothing is realistic—the cargo pants have a rugged, durable feel, while the top is snug and smooth.
                        The lighting accentuates her smooth skin and facial structure, casting soft shadows that add depth. The 3D model should include detailed facial 
                        features, expressive eyes, and a natural skin texture.
                        The background is sleek yet subtle, with a clean desk and a faint city skyline visible through a large window, hinting at ambition and a bright 
                        future. 

      The improved text gives a better non-biased results and a refined out because , it's specific, descriptive(well applied adjectives), The context of the image has been explained and photographic terminologies like, "realistic","casting shadows to add depth", have been used. 

    


